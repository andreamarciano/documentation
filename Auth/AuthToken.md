# üîê Access Tokens, Refresh Tokens & Bearer Authentication

Modern web applications often rely on **token-based authentication** using **JWTs (JSON Web Tokens)** to secure API access. Understanding how **access tokens**, **refresh tokens**, and **Bearer authentication** work is critical for building secure, user-friendly systems.

---

## üìö Table of Contents

1. [What is a JWT](#-what-is-a-jwt)
2. [Access Token](#-access-token)
3. [Refresh Token](#Ô∏è-refresh-token)
4. [Example Express Flow](#-example-express-flow)
5. [Security Best Practices](#-security-best-practices)

---

## üßæ What is a JWT?

A **JWT (JSON Web Token)** is a compact, URL-safe token used to securely transmit information between a client and a server. It is commonly used for **authentication and authorization** in modern web applications.

A JWT is composed of **three parts**:

```text
<HEADER>.<PAYLOAD>.<SIGNATURE>
```

Each part is **Base64Url encoded**.

### 1. Header

The **header** contains metadata about the token, such as:

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

- `alg`: The signing algorithm (e.g. HMAC SHA-256)
- `typ`: The type of token

### 2. Payload

The **payload** contains the actual data, called **claims**. These can be:

- **Standard claims**:

  - `sub` ‚Äì subject (usually the user ID)
  - `exp` ‚Äì expiration time (as a Unix timestamp)
  - `iat` ‚Äì issued at
  - `nbf` ‚Äì not before

- **Custom claims** (defined by you):

  - `role`, `email`, `username`, etc.

**Example payload:**

```json
{
  "sub": "user_123",
  "exp": 1719421440,
  "role": "user"
}
```

> ‚ö†Ô∏è Note: The payload is **not encrypted**, only base64-encoded. Never store sensitive information (like passwords) inside it.

### 3. Signature

The **signature** ensures the token has not been altered.

It is generated by hashing the header and payload with a secret key:

```text
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)
```

If any part of the token changes, the signature becomes invalid.

### üß™ Example JWT (encoded)

```text
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJzdWIiOiJ1c2VyXzEyMyIsImV4cCI6MTcxOTQyMTQ0MCwicm9sZSI6InVzZXIifQ.
dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
```

---

## üîë Access Token

- Short-lived (e.g. 15 minutes)
- Sent with each API request
- Encodes basic user info (e.g. ID, role)
- Used to **authorize** user actions

**Where is it used?**
Passed in the `Authorization` HTTP header:

```ts
Authorization: Bearer <access_token>
```

---

## ‚ôªÔ∏è Refresh Token

- Long-lived (e.g. 7‚Äì30 days)
- Stored securely (usually HTTP-only cookies)
- Used to **request a new access token** when the old one expires
- Never sent with every request

### ‚úÖ Flow Summary

1. User logs in ‚Üí Server responds with:

   - Access Token (expires in 15 min)
   - Refresh Token (expires in 7 days)
2. Client stores tokens:

   - Access Token ‚Üí memory or secure storage
   - Refresh Token ‚Üí **HTTP-only cookie**
3. On API requests:

   - Send `Authorization: Bearer <access_token>`
4. When the access token expires:

   - Client sends the refresh token to a `/refresh` endpoint
   - Server verifies it and issues a new access token

---

## üß™ Example Express Flow

### 1. Login Route (Issue Tokens)

```ts
import jwt from "jsonwebtoken";

app.post("/login", async (req, res) => {
  const user = await authenticate(req.body); // check credentials

  const accessToken = jwt.sign(
    { sub: user.id, role: user.role },
    ACCESS_SECRET,
    { expiresIn: "15m" }
  );

  const refreshToken = jwt.sign(
    { sub: user.id },
    REFRESH_SECRET,
    { expiresIn: "7d" }
  );

  res
    .cookie("refreshToken", refreshToken, {
      httpOnly: true,
      secure: true,
      sameSite: "strict",
    })
    .json({ accessToken });
});
```

### 2. Protected Route with Bearer Token

```ts
app.get("/profile", authenticateToken, (req, res) => {
  res.json({ message: "Secure data", user: req.user });
});

function authenticateToken(req, res, next) {
  const authHeader = req.headers["authorization"];
  const token = authHeader?.split(" ")[1];

  if (!token) return res.sendStatus(401);

  jwt.verify(token, ACCESS_SECRET, (err, user) => {
    if (err) return res.sendStatus(403);
    req.user = user;
    next();
  });
}
```

### 3. Refresh Token Route

```ts
app.post("/refresh", (req, res) => {
  const token = req.cookies.refreshToken;
  if (!token) return res.sendStatus(401);

  jwt.verify(token, REFRESH_SECRET, (err, decoded) => {
    if (err) return res.sendStatus(403);

    const newAccessToken = jwt.sign(
      { sub: decoded.sub },
      ACCESS_SECRET,
      { expiresIn: "15m" }
    );

    res.json({ accessToken: newAccessToken });
  });
});
```

---

## üõ° Security Best Practices

| Aspect        | Best Practice                                 |
| ------------- | --------------------------------------------- |
| Access Token  | Store in memory or localStorage (short-lived) |
| Refresh Token | Store in HTTP-only cookies (long-lived)       |
| HTTPS         | Always use HTTPS to avoid token leaks         |
| Rotation      | Optionally rotate refresh tokens on each use  |
| Logout        | Invalidate refresh tokens server-side         |
